import pygameimport osclass Tower(pygame.sprite.Sprite):    def __init__(self, name):        #super(Tower, self).__init__()        pygame.sprite.Sprite.__init__(self)        self.x = 450        self.y = 150        self.height = 96        self.width = 96        self.level = 1        self.animation_step = 0        self.shooting_right = False        self.is_shooting = True        # need to be overwritten in children        self.name = name        self.range = 250        self.cost = 50        self.sell_cost = 20        self.rate_of_fire = 10 # every X tick can shoot        self.damage = 1        self.tower_images = []        self.front_images = []        self.back_images = []        self.surface = pygame.Surface((self.width, self.height))        self.prepare_images()        self.rect = None    def draw(self, screen):            ''' Draws surface and calls move()'''            tower_image = pygame.image.load(self.tower_images[self.level - 1])            screen.blit(pygame.transform.scale(tower_image, (self.width, self.height)),                        (self.x - self.width / 2, self.y - self.height / 2))            self.rect = pygame.Rect(self.x - self.width / 2, self.y - self.height / 2, self.width, self.height) #  TODO REFACTORE            if self.is_shooting:                archer_image = pygame.image.load(self.front_images[self.animation_step])                if not self.shooting_right:                    archer_image = pygame.transform.flip(archer_image, True, False)            else:                archer_image = pygame.image.load(self.front_images[0])            screen.blit(pygame.transform.scale(archer_image, (32, 32)),                        (self.x - 32 / 2 - 12, self.y - 32 / 2 - 52 )) # magic numbers to position archer on top of tower            self.draw_range_circle(screen)            self.animation_step = (self.animation_step + 1) % 5    def distance_from(self, enemy):        ''' Sorting function to get distance from tower to enemy'''        tower_position = pygame.Vector2(self.x, self.y)        enemy_position = pygame.Vector2(enemy.x, enemy.y)        return tower_position.distance_to(enemy_position)    def attack(self, enemies):        ''' Sorts all enemies according to distance            Selects closest enemy and checks if is in range            Sets self.is_shooting to True if in range        '''        self.is_shooting = False        if enemies:            enemies.sort(key=self.distance_from)            closest_enemy = enemies[0]            enemy_position = pygame.Vector2(closest_enemy.x, closest_enemy.y)            tower_position = pygame.Vector2(self.x, self.y)            if tower_position.distance_to(enemy_position) <= self.range:                closest_enemy.hit(self.damage)                self.is_shooting = True    def draw_range_circle(self, screen):        '''        Draw range circle, mostly for debugging        :param self:        :param screen: Surface        :return: None        '''        #pygame.draw.circle(screen, pygame.Color('red'), (self.x, self.y), self.range, 2)        surface = pygame.Surface((self.range*2, self.range*2), pygame.SRCALPHA, 32)        pygame.draw.circle(surface, (128, 128, 128, 100), (self.range, self.range), self.range, 0)        screen.blit(surface, (self.x - self.range, self.y - self.range))    def move(self, pos):        ''' Sets x,y as a center, not top left, get_rect() needed to get top left point'''        self.x = pos[0]        self.y = pos[1]    def menu(self):            pass    def sell(self):            pass    def uprade(self):            pass    def get_rect(self):        ''' Get bounding rectangle for checking if clicked            self.x, self.y is center, rect needs to be around it, no starting from it        '''        return pygame.Rect(self.x - self.width / 2, self.y - self.height / 2, self.width, self.height)    def clicked(self, pos):        ''' Check if mouse event on 'pos' was inside of Button area '''        rect = self.get_rect()        return rect.collidepoint(pos)    def prepare_images(self):            '''            Prepare images and their animation:                self.tower_images - multiple images by level                self.front_images - animation of archer facing forward                self.back_images - animation of archer facing backwards            :param self:            :return:            '''            for i in range(3):                self.tower_images.append(                    os.path.join("game_assets", "towers", self.name, "level_{}.png".format(i+1)))            for i in range(6):                self.front_images.append(                    os.path.join("game_assets", "towers", self.name, "front_{}.png".format(i)))            for i in range(6):                self.back_images.append(                    os.path.join("game_assets", "towers", self.name, "back_{}.png".format(i)))